#### Thinking 1: 排序模型按照样本生成方法和损失函数的不同，可以划分成Pointwise，Pairwise 和 Listwise 三类方法，这三类排序方法有何区别。

**Pointwise**：按单样本进行训练，针对某个query，分别对每个doc判断相关度，算法相对简单，属于二分类问题，但不会考虑文档或样本间的相关关系。

- 损失函数：回归/分类 Loss，有序回归Loss

**Pairwise**：将训练样本转成多分类问题，并得到文档集合的偏序关系。缺点是只考虑了偏序关系，但实际上文档并不相互独立，而且容易对文档较多的查询偏移

- 损失函数：Pairwise 分类 Loss

**Listwise**：讲一次query对应的所有搜索结果作为训练样本，输出所有docs的打分或者排列顺序，优点是考虑到了最终排序结果，缺点是不好优化。

- 损失函数：NDCG（Normalized Discounted Cumulative Gain，归一化折损累计增益），MAP（Mean Average Precision 平均准确率）



#### Thinking 2：排序模型按照结构划分，可以分为线性排序模型、树模型、深度学习模型，这些模型都有哪些典型的代表？

线性排序模型：LR

树模型：GBDT，XGBoost，LightGBM

深度学习模型：DeepFM，NFM，PNN，RankNet



#### Thinking 3: NDCG 如何计算

能说明CG DCG IDCG NDCG的计算过程

1. CG = 累计增益，将每个推荐结果相关性的分支累加后，作为整个推荐列表的得分。**rel_i 表示出于位置 i 的推荐结果的相关性**，p为对应推荐列表的长度。 <font color=red> **缺点是不会考虑位置因素** </font>。

$$
CG_p = \sum_{i=1}^p rel_i
$$



2. DCG = 折损累计增益，是在每个CG的结果上除以折损值，让排名靠前的结果可以影响最后的结果。排序越靠后价值则越低。
   1. 缺点：DCG仅针对单一用户和单一推荐列表的效果进行评估，无法横向对其他列表评估，可能会导致影响整体效果。

$$
DCG_p = \sum_{i=1}^p \frac{rel_i}{log_2(i+1)}
$$



3. IDCG = 理想情况下最大的DCG值，如，推荐系统为某一用户返回的最好推荐结果列表（按相关性大到小排序），该序列的DCG就是IDCG

$$
IDCG_p = \sum_{i=1}^{|REL|}\frac{2^{rel_i}-1}{log_2(i+1)}
$$



4. NDCG = DCG / IDCG，归一化的贴现累积收益，综合考虑了排序模型结果和真实序列之间的关系，解决DCG无法针对两个不同搜索结果进行比较的问题。



#### Thinking 4： 搜索排序和推荐系统的相同和不同之处有哪些

搜索排序的推荐系统相同的地方是，两者都与大数据应用相关，通过用户行为为其推荐相关度较高的内容。而今年搜索和推荐也逐渐有了很多交叉的地方，比如搜索后对客户进行推荐。

不同点：搜索排序的结构是先搜索后排序，是通过用户的主动搜索行为得出结果后再对结果进行排序，获取信息的方式是用户主动且明确。 而推荐系统是机器通过用户的历史行为去猜客户想要的结果，并对猜测结果进行排序，从获取途径来看属于被动获取，且目标模糊。

从服务的角度看，搜索排序更多的是应对用户的临时查询需求，快速满足客户；而推荐系统则是需要通过持续的服务留住客户，同时可以通过客户历史行为，理解和挖掘更隐性的客户需求。



#### Thinking 5： Listwise 排序模型能否应用到推荐系统中

从概念上listwise是可以应用到推荐系统中的，一般推荐系统是先进行批量召回后，再进行排序，而listwise相当于直接返回一个排好序的 list of items，省去 recall 阶段。但是算法复杂度应该十分高，实践中体验和感知度应该不高。

